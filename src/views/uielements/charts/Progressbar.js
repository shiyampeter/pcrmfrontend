import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import PageBreadcrumbButton from '@/components/Common/PageBreadcrumbButton';
import { Row, Col, Card, Table } from 'react-bootstrap';
import { ProgressbarAnimationReactMove, ProgressbarAnimationReturning, ProgressbarAnimationSpeed, ProgressbarBasic, ProgressbarFilled, ProgressbarLinecap, } from '@/components/UiElements/Charts/Progressbar';
const Progressbar = () => {
    return (_jsxs(_Fragment, { children: [_jsx(PageBreadcrumbButton, { title: "ProgressBar", subName: "Charts", url: 'https://www.kevinqi.com/react-circular-progressbar/' }), _jsxs(Row, { className: "g-3 g-md-4", children: [_jsx(Col, { md: 6, lg: 4, xl: 6, xxl: 4, children: _jsxs(Card, { children: [_jsx(Card.Header, { children: _jsx(Card.Title, { children: "Basic" }) }), _jsx(Card.Body, { children: _jsx(ProgressbarBasic, {}) })] }) }), _jsx(Col, { md: 6, lg: 4, xl: 6, xxl: 4, children: _jsxs(Card, { children: [_jsx(Card.Header, { children: _jsx(Card.Title, { children: "Linecap" }) }), _jsx(Card.Body, { children: _jsx(ProgressbarLinecap, {}) })] }) }), _jsx(Col, { md: 6, lg: 4, xl: 6, xxl: 4, children: _jsxs(Card, { children: [_jsx(Card.Header, { children: _jsx(Card.Title, { children: "Filled" }) }), _jsx(Card.Body, { children: _jsx(ProgressbarFilled, {}) })] }) }), _jsx(Col, { md: 6, lg: 4, xl: 6, xxl: 4, children: _jsxs(Card, { children: [_jsx(Card.Header, { children: _jsx(Card.Title, { children: "Animation Speed" }) }), _jsx(Card.Body, { children: _jsx(ProgressbarAnimationSpeed, {}) })] }) }), _jsx(Col, { md: 6, lg: 4, xl: 6, xxl: 4, children: _jsxs(Card, { children: [_jsx(Card.Header, { children: _jsx(Card.Title, { children: "Animation Returning" }) }), _jsx(Card.Body, { children: _jsx(ProgressbarAnimationReturning, {}) })] }) }), _jsx(Col, { md: 6, lg: 4, xl: 6, xxl: 4, children: _jsxs(Card, { children: [_jsx(Card.Header, { children: _jsx(Card.Title, { children: "Animation React Move" }) }), _jsx(Card.Body, { children: _jsx(ProgressbarAnimationReactMove, {}) })] }) }), _jsx(Col, { xs: 12, children: _jsxs(Card, { children: [_jsx(Card.Header, { children: _jsx(Card.Title, { children: "Options" }) }), _jsxs(Table, { className: "mb-0", responsive: true, children: [_jsx("thead", { children: _jsxs("tr", { children: [_jsx("th", { children: "Option" }), _jsx("th", { children: "Type" }), _jsx("th", { children: "Default" }), _jsx("th", { children: "Description" })] }) }), _jsxs("tbody", { children: [_jsxs("tr", { children: [_jsx("td", { children: "value" }), _jsx("td", { children: "Number" }), _jsx("td", { children: "Indeterminate" }), _jsx("td", { children: "Current value" })] }), _jsxs("tr", { children: [_jsx("td", { children: "min" }), _jsx("td", { children: "Number" }), _jsx("td", { children: "0" }), _jsx("td", { children: "Minimum value" })] }), _jsxs("tr", { children: [_jsx("td", { children: "max" }), _jsx("td", { children: "Number" }), _jsx("td", { children: "1" }), _jsx("td", { children: "Maximum value" })] }), _jsxs("tr", { children: [_jsx("td", { children: "startAngle" }), _jsx("td", { children: "Number" }), _jsx("td", { children: "0" }), _jsxs("td", { children: ["Starting angle in degrees. Angle of 0 points straight up. Direction depends on", ' ', _jsx("code", { children: "anticlockwise" }), "."] })] }), _jsxs("tr", { children: [_jsx("td", { children: "anticlockwise" }), _jsx("td", { children: "Boolean" }), _jsx("td", { children: "false" }), _jsx("td", { children: "Whether to rotate anti-clockwise (true) or clockwise (false)" })] }), _jsxs("tr", { children: [_jsx("td", { children: "unconstrained" }), _jsx("td", { children: "Boolean" }), _jsx("td", { children: "false" }), _jsxs("td", { children: ["Whether the value should be constrained between ", _jsx("code", { children: "min" }), " and", ' ', _jsx("code", { children: "max" }), ". If false, values over ", _jsx("code", { children: "max" }), " will be truncated to", ' ', _jsx("code", { children: "max" }), " and values under ", _jsx("code", { children: "min" }), " will be set to", ' ', _jsx("code", { children: "min" }), "."] })] }), _jsxs("tr", { children: [_jsx("td", { children: "indeterminateText" }), _jsx("td", { children: "String" }), _jsx("td", { children: "'?'" }), _jsx("td", { children: "Text to display as the value when it is indeterminate" })] }), _jsxs("tr", { children: [_jsx("td", { children: "textFormat" }), _jsx("td", { children: "String or Function" }), _jsx("td", { children: "'horizontal'" }), _jsxs("td", { children: ["Text layout for value, min, max. ", _jsx("br", {}), "You can pass either one of the possible keywords: ", _jsx("br", {}), _jsx("code", { children: "horizontal" }), " - ", _jsx("samp", { children: "value/max" }), " ", _jsx("br", {}), _jsx("code", { children: "vertical" }), " - value is shown over max ", _jsx("br", {}), _jsx("code", { children: "percent" }), " - ", _jsx("samp", { children: "value%" }), " ", _jsx("br", {}), _jsx("code", { children: "value" }), " - only value is shown ", _jsx("br", {}), _jsx("code", { children: "valueOnCircle" }), " - the value is painted on top of the filled region on the circle ", _jsx("br", {}), _jsx("code", { children: "none" }), " - no text is shown. ", _jsx("br", {}), "Alternatively you can provide your own function, which will be called each time progress is updated with value and max as arguments, and is expected to return a string of HTML to insert in the center of the progress circle.", ' ', _jsx("strong", { children: "Attention! The string returned from your function will be inserted as HTML. Do not pass any dynamic content such as variables coming from elsewhere to avoid XSS vulnerability." })] })] }), _jsxs("tr", { children: [_jsx("td", { children: "animation" }), _jsx("td", { children: "String or Function" }), _jsx("td", { children: "'easeInOutCubic'" }), _jsxs("td", { children: ["Animation easing function. Can be a string keyword (see the table below for available easings) or ", _jsx("code", { children: "'none'" }), ".", _jsx("br", {}), "Alternatively, you can pass your own function with the signature ", _jsx("br", {}), _jsx("code", { children: "function(time, startAngle, angleDiff, duration)" }), ".", _jsx("br", {}), "The function will be called on each animation frame with the current time (milliseconds since animation start), starting angle, difference in angle (i.e. endAngle - startAngle) and animation duration as arguments, and must return the current angle."] })] }), _jsxs("tr", { children: [_jsx("td", { children: "animationDuration" }), _jsx("td", { children: "Number" }), _jsx("td", { children: "600" }), _jsx("td", { children: "Animation duration in milliseconds" })] })] })] })] }) })] })] }));
};
export default Progressbar;
